const fs = require('fs');
const chalk = require('chalk');
const inquirer = require('inquirer');
const api = require('../utils/api');

module.exports = async (options) => {
  if (!fs.existsSync('.envdock.json')) return console.log(chalk.red('Run `edk link` first.'));

  const localConfig = JSON.parse(fs.readFileSync('.envdock.json'));
  const filename = '.env';

  const envName = (options.env || localConfig.env || 'dev').toLowerCase();

  // 2. Define allowed tiers
  const ALLOWED_ENVS = ['dev', 'staging', 'prod'];

  // 3. Strict Validation
  if (!ALLOWED_ENVS.includes(envName)) {
    console.log(chalk.red(`\n❌ Invalid environment: ${chalk.bold(envName)}`));
    console.log(chalk.white(`Please specify one of the following: ${ALLOWED_ENVS.map(e => chalk.cyan(e)).join(', ')}`));
    console.log(chalk.gray(`\nExample: edk pull -e staging`));
    return; // Stop execution
  }

  // 1. Safety Check
  if (fs.existsSync(filename)) {
    // Read first to see if it's identical? (Optional optimization)
    const { confirm } = await inquirer.prompt([{
      type: 'confirm',
      name: 'confirm',
      message: `A ${filename} file already exists. Overwrite it?`,
      default: false
    }]);
    if (!confirm) return;
  }

  try {
    const { data: secrets } = await api.get(`/cli/${localConfig.projectId}?env=${envName}`);

    let envContent = `# Generated by EnvDock [${envName}] - ${new Date().toISOString()}\n\n`;
    for (const [key, value] of Object.entries(secrets)) {
      // Wrap in quotes if it contains spaces or special chars
      const safeValue = /[\s#]/.test(value) ? `"${value}"` : value;
      envContent += `${key}=${safeValue}\n`;
    }

    fs.writeFileSync(filename, envContent);
    console.log(chalk.green(`✅ Pulled ${Object.keys(secrets).length} secrets to ${filename}`));

  } catch (error) {
    console.error(chalk.red('Error:'), error.response?.data?.message || error.message);
  }
};